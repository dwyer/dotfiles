#!/usr/bin/env python

"""
ipod interface: a vim-like ncurses-based interface for your ipod.

Hotkeys for edit mode:
    Up, arrow, down arrow, page up, page down, home, end and delete all do what
    you would expect. The following not as intuitive unless you use vim:

Navigation:
    j: move down
    k: move up

Search:
    /: find next
    ?: find previous
    n: repeat find
    N: repeat reverse find

Modifcation:
    d: delete
    u: undo

Repetition:
    Entering a number N before a command will repeat the command N times.

Quit:
    q: quit
"""

import argparse
import curses
import curses.textpad
import locale
import re
import sys

import gpod

# key bindings
keys = {
    'dn': [ord('j'), curses.KEY_DOWN],
    'up': [ord('k'), curses.KEY_UP],
    'del': [ord('d'), curses.KEY_DC],
    'undo': [ord('u')],
    'quit': [ord('q')],
    'find': [ord('/')],
    'findp': [ord('?')],
    'next': [ord('n')],
    'prev': [ord('N')],
    'pgdn': [curses.KEY_NPAGE],
    'pgup': [curses.KEY_PPAGE],
    'home': [curses.KEY_HOME],
    'end': [curses.KEY_END],
}

# these are the fields to use when printing a track
track_fields = ['artist', 'album', 'track_nr', 'title']
track_field_sep = ' - '

parser = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=
                                 argparse.RawDescriptionHelpFormatter)
parser.add_argument('ls', nargs='?')
args = parser.parse_args()

try:
    db = gpod.Database() # todo: let user select mountpoint
    pl = db.get_master() # todo: let user select playlist

except gpod.ipod.DatabaseException, e:
    print 'Error:', e
    sys.exit(1)
except AttributeError:
    print 'Error:', e
    sys.exit(1)

if args.ls:
    for pl in db.get_playlists():
        print pl
    sys.exit(0)

locale.setlocale(locale.LC_ALL, '')
code = locale.getpreferredencoding()

def track_to_str(track):
    s = track_field_sep.join(str(track[key]) for key in track_fields)
    return s.encode(code)

tracks = [(track_to_str(track), track) for track in pl]
trash = []
history = []

def do(n, something, *args, **kwargs):
    """do something n times"""
    ret = None
    for i in xrange(n or 1):
        ret = something(*args, **kwargs)
    return ret

def delete(n):
    """delete track n from playlist"""
    trash.append(tracks.pop(n))
    history.append(n)

def undo():
    if not history:
        return 0
    n = history.pop()
    tracks.insert(n, trash.pop())
    return n

def getstr(scr, y, prompt=''):
    curses.curs_set(1)
    curses.echo()
    scr.addstr(y, 0, prompt)
    ret = scr.getstr(y, len(prompt))
    curses.curs_set(0)
    curses.noecho()
    return ret

def find(pattern, playlist):
    """find pattern in playlist, return its index or -1 if it can't be found"""
    pattern = pattern.lower()
    for i, (s, t) in enumerate(playlist):
        if pattern in s.lower():
            return i
    return -1

def find_next(pattern, playlist, start):
    """find next pattern in playlist starting from start"""
    return start + find(pattern, playlist[start+1:]) + 1

def find_prev(pattern, playlist, start):
    """find previous pattern in playlist starting from start"""
    return start - find(pattern, reversed(playlist[:start])) - 1

def edit_mode(scr):
    global tracks, trash
    repeat = 0
    scr_pos = 0
    usr_pos = 0
    search = ''
    curses.use_default_colors()
    curses.curs_set(0) # we'll use our own cursor.
    keys['digits'] = [i + ord('0') for i in xrange(10)]
    while 1:
        # output
        scr.clear()
        h, w = scr.getmaxyx()
        h -= 1
        for y, (s, track) in enumerate(tracks[scr_pos:scr_pos + h]):
            color = curses.A_REVERSE if y + scr_pos == usr_pos else 0
            scr.addnstr(y, 0, s, w - 1, color)
        scr.refresh()
        # input
        c = scr.getch()
        if c in keys['quit']:
            break
        elif c in keys['dn']:
            usr_pos += 1 * (repeat or 1)
        elif c in keys['up']:
            usr_pos -= 1 * (repeat or 1)
        elif c in keys['pgdn']:
            usr_pos += h * (repeat or 1)
        elif c in keys['pgup']:
            usr_pos -= h * (repeat or 1)
        elif c in keys['home']:
            usr_pos = 0
        elif c in keys['end']:
            usr_pos = len(tracks)
        elif c in keys['del']:
            for i in xrange(repeat or 1):
                delete(usr_pos)
        elif c in keys['undo']:
            for i in xrange(repeat or 1):
                usr_pos = undo()
        elif c in keys['find']:
            search = getstr(scr, h, '/')
            for i in xrange(repeat or 1):
                usr_pos = find_next(search, tracks, usr_pos)
        elif c in keys['findp']:
            search = getstr(scr, h, '?')
            for i in xrange(repeat or 1):
                usr_pos = find_prev(search, tracks, usr_pos)
        elif c in keys['next']:
            for i in xrange(repeat or 1):
                usr_pos = find_next(search, tracks, usr_pos)
        elif c in keys['prev']:
            for i in xrange(repeat or 1):
                usr_pos = find_prev(search, tracks, usr_pos)
        elif c in keys['digits']:
            repeat *= 10
            repeat += int(chr(c))
        # clear repeat if the last c wasn't a digit
        if c not in keys['digits']:
            repeat = 0
        # keep the user in the list
        if usr_pos < 0:
            usr_pos = 0
        elif usr_pos >= len(tracks):
            usr_pos = len(tracks) - 1
        # keep the screen focused on the user
        if scr_pos > usr_pos:
            scr_pos = usr_pos
        elif scr_pos < usr_pos - h + 1:
            scr_pos = usr_pos - h + 1
    curses.endwin()

curses.wrapper(edit_mode)

if trash:
    print 'Are you sure you want to delete the following tracks?'
    for s, track in trash:
        print ' ', s
